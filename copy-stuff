#!/usr/bin/perl

use FindBin;
use lib "$FindBin::Bin/../lib/perl";
my $BASEDIR = "$FindBin::Bin/..";
my $target = "$BASEDIR/Data";
my $source = "$BASEDIR/CCO_DATA";

use strict;
use warnings;

my @files = find_all( $source );
FILE: foreach my $file ( @files )
{
	# try to work out the bits of this filename into something logical

	# skip file formats we don't care about
	next FILE if( $file =~ /\.(txt|Tab|tab|xls|eww|pdf|xml|dbf|jpgw|xlsx)$/ ); 

	my @path = split( '/', $file );
	shift @path;

	my $top = shift @path;

	my $ok = $top =~ m/^(\d\d\d\d(_\d\d)?)_(lidar|bathy|aerial)/i;
	if( !$ok ) 
	{	
		die "failed to match $top in top regexp";
	}
	my $year = $1;
	my $type = { lidar=>"LIDAR", bathy=>"Bathy", aerial=>"Aerial" }->{lc $3};
	if( !defined $type ) { die "dang $3"; }
	my $subtype;
	#print $top." :: $year :: $type\n";
	#print join( " / ", @path )."\n";

	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d).*\.asc$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/ASCII/$1_$2.asc" );
		next FILE;
	}
	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d).*\.ecw$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/ECW/$1_$2.ecw" );
		next FILE;
	}

	$subtype = "ASCII_Surface" if( $path[0] eq "ASCII" ); 
	$subtype = "ASCII_Surface" if( $path[0] eq "DSM" ); 
	$subtype = "ASCII_Terrain" if( $path[0] eq "DTM" ); 
	$subtype = "XYZ" if( $path[0] eq "XYZ" ); 

	die "No SUBTYPE for $path[0]" if !defined $subtype;
	shift @path;

	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d)(ne|se|nw|sw).*\.asc$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype-500m/$1_$2_$3.asc" );
		next FILE;
	}
	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d).*\.asc$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype/$1_$2.asc" );
		next FILE;
	}
	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d).*\.xyz$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype/$1_$2.xyz" );
		next FILE;
	}

	if( $path[0] eq "DSM" )
	{
		if( $subtype eq "XYZ" )
		{
			$subtype = "XYZ_Surface";
		}
		else
		{
			$subtype = "ASCII_Surface";
		}
	}
	if( $path[0] eq "DTM" )
	{
		if( $subtype eq "XYZ" )
		{
			$subtype = "XYZ_Terrain";
		}
		else
		{
			$subtype = "ASCII_Terrain";
		}
	}
	$subtype = "JPEG" if( $path[0] eq "Jpegs" ); 

	die "No SUBTYPE for $path[0]" if !defined $subtype;
	shift @path;

	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d)(ne|se|nw|sw).*\.xyz$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype-500m/$1_$2_$3.xyz" );
		next FILE;
	}
	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d)(ne|se|nw|sw).*\.asc$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype-500m/$1_$2_$3.asc" );
		next FILE;
	}
	if( $path[0] =~ m/^[A-Z][A-Z](\d\d)(\d\d).*\.(asc|xyz|jpg)$/i )
	{
		file_copy( $source."/".$file, "$target/$type/$year/$subtype/$1_$2.$3" );
		next FILE;
	}


	print $path[0]."\n";
}
exit;

sub file_copy
{
	my( $src, $dest ) = @_;

	my $size = (stat $src)[7];

	my @dest_path = split( '/', $dest );
	pop @dest_path;
	shift @dest_path;
	my $dest_i = "";
	foreach my $path_bit ( @dest_path )
	{
		$dest_i .= '/'.$path_bit;
		if( ! -d $dest_i )
		{
			mkdir( $dest_i );
		}
	}

	
	my $v=1;
	my $dest2 = $dest;
	if( -e $dest.".1" )
	{
		$dest2 = $dest.".1";
	}
	my $altered_dest = 0;
	while( -e $dest2 )
	{
		my $size2 = (stat $dest2)[7];
		if( $size2 == $size ) 
		{ 
			print "No need to copy. Both files are $size sized.\n"; 
			return;
		}

		$v++;
		$dest2 = $dest.".".$v;
		$altered_dest = 1;
	}
	my $cmd = "cp '$src' '$dest2'";
	print "$cmd\n";
	`$cmd`;
	if( -e $dest && $altered_dest )
	{
		my $cmd = "mv '$dest' '$dest.1'";
		print "$cmd\n";
		`$cmd`;
	}

}

sub find_all
{
	my( $dir, $path ) = @_;
	
	$path = "" if !defined $path;

	my @files = ();
	my @dirs = ();
	opendir( my $dh, $dir ) || die "Failed to readdir $dir\n";
	while( my $file = readdir( $dh ) )
	{
		next if( $file eq "." );
		next if( $file eq ".." );
		if( -d "$dir/$file" )
		{
			push @dirs, $file;
		}
		else
		{
			push @files, $path."/".$file;
		}
	}
	closedir( $dh );

	foreach my $sub_dir ( @dirs )
	{
		push @files, find_all( "$dir/$sub_dir", "$path/$sub_dir" );
	}

	return @files;
}
